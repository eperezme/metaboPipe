variable_meta = VM,
name = 'STATegra Metabolomics LCMS',
description = 'https://www.nature.com/articles/s41597-019-0202-7'
)
DE
DE\
DE
View(DE)
filter_MV <- function(dataset_exp, threshold = 0.8) {
# Check if threshold is specified and valid
if (missing(threshold)) {
threshold <- 0.8  # Default threshold
cat("No threshold specified. Defaulting to 0.8.\n")
} else {
# Check if threshold is between 0 and 1
if (threshold < 0 || threshold > 1) {
stop("Threshold must be between 0 and 1.")
}
# Check if threshold is a numeric value
if (!is.numeric(threshold)) {
stop("Threshold must be a numeric value.")
}
cat(paste0("Threshold value: ", threshold, "\n"))
}
# Calculate number of rows and columns in the dataset
nrows <- nrow(assay(dataset_exp))
ncols <- ncol(assay(dataset_exp))
# Calculate the threshold values based on the modified 80% rule
row_threshold <- ncols * threshold
col_threshold <- nrows * threshold
# Filter rows based on the modified 80% rule
row_counts <- rowSums(!is.na(assay(dataset_exp)))
dataset_exp <- dataset_exp[row_counts >= row_threshold, ]
# Filter columns based on the modified 80% rule
col_counts <- colSums(!is.na(assay(dataset_exp)))
dataset_exp <- dataset_exp[, col_counts >= col_threshold]
# Calculate the number of rows and columns removed
removed_rows <- nrows - sum(row_counts >= row_threshold)
removed_cols <- ncols - sum(col_counts >= col_threshold)
# Print information about removed rows and columns
if (removed_rows == 0) {
cat('No rows removed\n')
} else {
cat(paste0('Number of rows removed: ', removed_rows, '\n'))
}
if (removed_cols == 0) {
cat('No columns removed\n')
} else {
cat(paste0('Number of columns removed: ', removed_cols, '\n'))
}
return(dataset_exp)
}
aggr(assay(DE))
DE_f<- filter_MV(DE, threshold = 0.8)
aggr(assay(DE_f))
C = mv_histogram(by_sample = FALSE)
chart_plot(C, DE)
chart_plot(C, DE_f)
# Impute Missing Values
library(mice)
library(missForest)
# Impute missing values using missForest
DE_impForest <- missForest(assay(DE_f), maxiter = 10, ntree = 100)
# Impute missing values using MICE
DE_impMice <- mice(assay(DE_f), m = 5, maxit = 50, method = 'pmm')
View(VM)
View(SM)
View(X)
View(VM)
View(SM)
View(SM)
md.pattern(assay(DE))
md.pattern(assay(DE_f))
DE_f
DE
# Impute missing values using MICE
imp <- mice(assay(DE_f), m = 5, maxit = 50, method = 'pmm')
# Impute missing values using MICE
imp <- mice(DE_f$data, m = 5, maxit = 50, method = 'pmm')
# Impute missing values using MICE
imp <- mice(DE_f$data$L_Histidine_13C, m = 5, maxit = 50, method = 'pmm')
# Impute missing values using MICE
imp <- mice(matrix(DE_f$data), m = 5, maxit = 50, method = 'pmm')
matrix(DE_f$data)
# Impute missing values using MICE
imp <- mice(as.matrix(DE_f$data), m = 5, maxit = 50, method = 'pmm')
as.matrix(DE_f$data)
a <- as.matrix(DE_f$data)
View(a)
a <- as.matrix(assay(DE_f))
View(a)
colnames(a) <- 1:ncol(a)
View(a)
imp <- mice(a, m = 5, maxit = 50, method = 'pmm')
install.packages("MAI")
library(MAI)
Results = MAI(DE_f, # The data with missing values
MCAR_algorithm = "random_forest", # The MCAR algorithm to use
MNAR_algorithm= "Single", # The MNAR algorithm to use
assay_ix = 1, # If SE, designates the assay to impute
forest_list_args = list( # random forest arguments for training
ntree = 300,
proximity = FALSE
),
verbose = TRUE # allows console message output
)
View(Results)
Results, param = MAI(DE_f, # The data with missing values
Results = MAI(assay(DE_f), # The data with missing values
MCAR_algorithm = "random_forest", # The MCAR algorithm to use
MNAR_algorithm= "Single", # The MNAR algorithm to use
forest_list_args = list( # random forest arguments for training
ntree = 300,
proximity = FALSE
),
verbose = TRUE # allows console message output
)
Results[["Estimated_Params"]]
Results = MAI(assay(DE_f), # The data with missing values
n_cores = -1,
MCAR_algorithm = "random_forest", # The MCAR algorithm to use
MNAR_algorithm= "Single", # The MNAR algorithm to use
forest_list_args = list( # random forest arguments for training
ntree = 300,
proximity = FALSE
),
verbose = TRUE # allows console message output
)
install.packages("imputeLCMD")
library(imputeLCMD)
# Impute missing values using imputeLCMD
library(imputeLCMD)
?imputeLCMD
# Impute missing values using imputeLCMD
library(imputeLCMD)
DE_impLCMD <- impute.QRILC(assay(DE_f))
View(DE_impLCMD)
impute.QRILC(DE_impLCMD)
DE_impLCMD <- DE_F
DE_impLCMD <- DE_f
impute.QRILC(DE_impLCMD)
impute.QRILC(DE_impLCMD$data)
DE_impLCMD <- DE_f
impute.QRILC(DE_impLCMD$data)
DE_impLCMD <- DE_f
DE_impLCMD$data <-  impute.QRILC(DE_impLCMD$data)
DE_impLCMD$data <-  impute.QRILC(assay(DE_f))
DE_impLCMD <- DE_f
assay(DE_impLCMD) <-  impute.QRILC(assay(DE_impLCMD))
DE_impLCMD@assays@data
View(DE_impLCMD@assays@data@listData[[1]])
DE_impLCMD@assays@data@listData[[1]]) <-  impute.LCMD(DE_impLCMD@assays@data@listData[[1]])
DE_impLCMD@assays@data@listData[[1]] <-  impute.LCMD(DE_impLCMD@assays@data@listData[[1]])
DE_impLCMD@assays@data@listData[[1]] <-  impute.QRILC(DE_impLCMD@assays@data@listData[[1]])
DE_impLCMD <- imputeLCMD(assay(DE_f))
DE_impLCMD <- impute.QRILC(assay(DE_f))
aggr(DE_impLCMD)
DE_impLCMD
# Impute Missing Values
# Impute missing values using missForest
library(missForest)
DE_impForest <- missForest(assay(DE_f), maxiter = 10, ntree = 100)
# Impute missing values using imputeLCMD
library(imputeLCMD)
DE_impLCMD <- impute.QRILC(assay(DE_f))
# Compare the imputed datasets
aggr(assay(DE_f))
# aggr(DE_impForest$ximp)
# aggr(DE_impLCMD)
View(DE_impLCMD)
QRILC_result <- impute.QRILC(assay(DE_f))
DE_impLCMD <- QRILC_result[[1]]
DE_impLCMD <- DE_f
assay(DE_impLCMD) <- QRILC_result[[1]]
aggr(assay(QRILC_result[[1]]))))
aggr(assay(DE_impLCMD))
DE_impForest <- missForest(assay(DE_f), maxiter = 10, ntree = 100)
DE_impForest <- DE_f
forest_result <- missForest(assay(DE_f), maxiter = 10, ntree = 100)
View(forest_result)
assay(DE_impForest) <- forest_result$ximp
PCA(DE_impForest, number_components = 5)
PCA(DE_f, number_components = 5)
P <- PCA(number_components = 5)
P <-  model_apply(P, DE_impForest)
Q <- PCA(number_components = 5)
Q <-  model_apply(Q, DE_impLCMD)
C = pca_scores_plot(factor_name = k)
g = list()
for (k in colnames(DE_impForest$sample_meta)) {
C = pca_scores_plot(factor_name = k)
g[[k]] = chart_plot(C,P[2])
}
C = pca_scores_plot(factor_name = 'condition')
chart_plot(C, P)
P <- PCA(number_components = 5)
PF <-  model_apply(P, DE_impForest)
PQ <-  model_apply(P, DE_impLCMD)
chart_plot(C, PF)
chart_plot(C, PQ)
C = pca_scores_plot(factor_name = 'condition')
chart_plot(C, PF)
chart_plot(C, PQ)
PDE <-  model_apply(P, DE)
impute_QRILC <- function(dataset_experiment) {
# Load required library
library(imputeLCMD)
# Create a copy of the DatasetExperiment object
DE_imp <- dataset_experiment
# Impute missing values
imputed_data <- impute.QRILC(assay(dataset_experiment))
# Replace missing values with imputed values
assay(DE_imp) <- imputed_data[[1]]
return(DE_imp)
}
DE_QRILC <- impute_QRILC(DE)
PDE <-  model_apply(P, DE)
PDE <-  model_apply(P, DE_QRILC)
C = pca_scores_plot(factor_name = 'condition')
chart_plot(C, PDE)
impute_forest <- function(dataset_experiment) {
# Load required library
library(missForest)
# Create a copy of the DatasetExperiment object
DE_imp <- dataset_experiment
# Impute missing values
forest_result <- missForest(assay(dataset_experiment), maxiter = 10, ntree = 100)
# Replace missing values with imputed values
assay(DE_imp) <- forest_result$ximp
return(DE_imp)
}
DE_Forest <- impute_forest(DE)
DE_Forest <- impute_forest(DE)
C = pca_scores_plot(factor_nam
C = pca_scores_plot(factor_nam
DE_Forest <- impute_forest(DE)
PFDE <- model_apply(P, DE_Forest)
C = pca_scores_plot(factor_name = 'condition')
chart_plot(C, PFDE)
chart_plot(C, PF)
chart_plot(C, PQ)
chart_plot(C, PDE)
chart_plot(C, PFDE)
AP <- autoscale() + PCA(number_components = 5)
APF <- model_apply(AP, DE_impForest)
APDE <- model_apply(AP, DE_QRILC)
APFDE <- model_apply(AP, DE_Forest)
C = pca_scores_plot(factor_name = 'condition')
chart_plot(C, AP)
chart_plot(C, APF)
chart_plot(C, APQ)
chart_plot(C, AP)
AP <- autoscale() + PCA(number_components = 5)
APF <- model_apply(AP, DE_impForest)
APQ <- model_apply(AP, DE_impLCMD)
APDE <- model_apply(AP, DE_QRILC)
APFDE <- model_apply(AP, DE_Forest)
chart_plot(C, APF)
APF
chart_plot(C, APF[2])
P <- PCA(number_components = 5)
PF <-  model_apply(P, DE_impForest)
PQ <-  model_apply(P, DE_impLCMD)
PDE <-  model_apply(P, DE_QRILC)
PFDE <- model_apply(P, DE_Forest)
AP <- autoscale() + PCA(number_components = 5)
APF <- model_apply(AP, DE_impForest)
APQ <- model_apply(AP, DE_impLCMD)
APDE <- model_apply(AP, DE_QRILC)
APFDE <- model_apply(AP, DE_Forest)
C = pca_scores_plot(factor_name = 'condition')
chart_plot(C, PF)
chart_plot(C, PQ)
chart_plot(C, PDE)
chart_plot(C, PFDE)
chart_plot(C, APF[2])
chart_plot(C, APQ[2])
chart_plot(C, APDE[2])
chart_plot(C, APFDE[2])
## install additional bioc packages for vignette if needed
#BiocManager::install(c('pmp', 'ropls', 'BiocFileCache'))
## install additional CRAN packages if needed
#install.packages(c('cowplot', 'openxlsx'))
suppressPackageStartupMessages({
# Bioconductor packages
library(SummarizedExperiment)
library(structToolbox)
library(pmp)
library(ropls)
library(BiocFileCache)
# CRAN libraries
library(ggplot2)
library(gridExtra)
library(cowplot)
library(openxlsx)
library(VIM)
})
# use the BiocFileCache
bfc <- BiocFileCache(ask = FALSE)
# path to zip
zipfile = "https://raw.github.com/STATegraData/STATegraData/master/Script_STATegra_Metabolomics.zip"
## retrieve from BiocFileCache
path = bfcrpath(bfc,zipfile)
temp = bfccache(bfc)
## ... or download to temp location
# path = tempfile()
# temp = tempdir()
# download.file(zipfile,path)
# unzip
unzip(zipfile=path, files = "LC_MS_raw_data.xlsx", exdir=temp)
# read samples
data <- as.data.frame(read.xlsx(file.path(temp,"LC_MS_raw_data.xlsx"),sheet = 'Data'))
# extract sample meta data (Cols 1 to 8)
SM = data[ ,1:8]
# add coloumn for sample type (QC, blank etc)
# Add blanks id
blanks=c(1,2,33,34,65,66)
# add QC id
QCs=c(3,4,11,18,25,32,35,36,43,50,57,64)
# add sample type
SM$sample_type='Sample'
# add blanks
SM$sample_type[blanks]='Blank'
# add QCs
SM$sample_type[QCs]='QC'
# put qc/blank labels in all factors for plotting later
SM$biol.batch[SM$sample_type!='Sample']=SM$sample_type[SM$sample_type!='Sample']
SM$time.point[SM$sample_type!='Sample']=SM$sample_type[SM$sample_type!='Sample']
SM$condition[SM$sample_type!='Sample']=SM$sample_type[SM$sample_type!='Sample']
# convert to factors
SM$biol.batch=ordered(SM$biol.batch,c('9','10','11','12','QC','Blank'))
SM$time.point=ordered(SM$time.point,c('0h','2h','6h','12h','18h','24h','QC','Blank'))
SM$condition=factor(SM$condition)
SM$sample_type=factor(SM$sample_type)
# variable meta data
# Use the colnames of the data as the variable meta data
colnames(data)=gsub("-", "_", colnames(data))
VM = data.frame('annotation'=colnames(data)[9:ncol(data)])
# Create the raw data matrix
X = data[,9:ncol(data)]
# convert 0 to NA
X[X==0]=NA
# force to numeric; any non-numerics will become NA
X=data.frame(lapply(X,as.numeric),check.names = FALSE)
# make sure row/col names match
rownames(X)=data$label
rownames(SM)=data$label
rownames(VM)=colnames(X)
# create DatasetExperiment object
DE = DatasetExperiment(
data = X,
sample_meta = SM,
variable_meta = VM,
name = 'STATegra Metabolomics LCMS',
description = 'https://www.nature.com/articles/s41597-019-0202-7'
)
DE
# prepare model sequence
MS = filter_smeta(mode = 'include', levels='QC', factor_name = 'sample_type') +
knn_impute(neighbours=5) +
vec_norm() +
log_transform(base = 10)
# apply model sequence
MS = model_apply(MS, DE)
install_github("JoeRothwell/pcpr2")
library(devtools)
install_github("JoeRothwell/pcpr2")
library(pcpr2)
filter_MV <- function(dataset_exp, threshold = 0.8) {
# Check if threshold is specified and valid
if (missing(threshold)) {
threshold <- 0.8  # Default threshold
cat("No threshold specified. Defaulting to 0.8.\n")
} else {
# Check if threshold is between 0 and 1
if (threshold < 0 || threshold > 1) {
stop("Threshold must be between 0 and 1.")
}
# Check if threshold is a numeric value
if (!is.numeric(threshold)) {
stop("Threshold must be a numeric value.")
}
cat(paste0("Threshold value: ", threshold, "\n"))
}
# Calculate number of rows and columns in the dataset
nrows <- nrow(assay(dataset_exp))
ncols <- ncol(assay(dataset_exp))
# Calculate the threshold values based on the modified 80% rule
row_threshold <- ncols * threshold
col_threshold <- nrows * threshold
# Filter rows based on the modified 80% rule
row_counts <- rowSums(!is.na(assay(dataset_exp)))
dataset_exp <- dataset_exp[row_counts >= row_threshold, ]
# Filter columns based on the modified 80% rule
col_counts <- colSums(!is.na(assay(dataset_exp)))
dataset_exp <- dataset_exp[, col_counts >= col_threshold]
# Calculate the number of rows and columns removed
removed_rows <- nrows - sum(row_counts >= row_threshold)
removed_cols <- ncols - sum(col_counts >= col_threshold)
# Print information about removed rows and columns
if (removed_rows == 0) {
cat('No rows removed\n')
} else {
cat(paste0('Number of rows removed: ', removed_rows, '\n'))
}
if (removed_cols == 0) {
cat('No columns removed\n')
} else {
cat(paste0('Number of columns removed: ', removed_cols, '\n'))
}
return(dataset_exp)
}
aggr(assay(DE))
DE_f<- filter_MV(DE, threshold = 0.8)
aggr(assay(DE_f))
C = mv_histogram(by_sample = FALSE)
chart_plot(C, DE)
chart_plot(C, DE_f)
# Impute Missing Values
# Impute missing values using missForest
library(missForest)
# Create new DatasetExperiment object
DE_impForest <- DE_f
# Impute missing values
forest_result <- missForest(assay(DE_f), maxiter = 10, ntree = 100)
# Replace missing values with imputed values
assay(DE_impForest) <- forest_result$ximp
impute_forest <- function(dataset_experiment) {
# Load required library
library(missForest)
# Create a copy of the DatasetExperiment object
DE_imp <- dataset_experiment
# Impute missing values
forest_result <- missForest(assay(dataset_experiment), maxiter = 10, ntree = 100)
# Replace missing values with imputed values
assay(DE_imp) <- forest_result$ximp
return(DE_imp)
}
# Impute missing values using imputeLCMD
library(imputeLCMD)
# Create new DatasetExperiment object
DE_impLCMD <- DE_f
# Impute missing values
QRILC_result <- impute.QRILC(assay(DE_f))
# Replace missing values with imputed values
assay(DE_impLCMD) <- QRILC_result[[1]]
impute_QRILC <- function(dataset_experiment) {
# Load required library
library(imputeLCMD)
# Create a copy of the DatasetExperiment object
DE_imp <- dataset_experiment
# Impute missing values
imputed_data <- impute.QRILC(assay(dataset_experiment))
# Replace missing values with imputed values
assay(DE_imp) <- imputed_data[[1]]
return(DE_imp)
}
output <- runPCPR2(assay(DE_impLCMD), DE_impLCMD$sample_meta, pct.threshold = .8)
output <- runPCPR2(assay(DE_impLCMD), DE_impLCMD$sample_meta, pct.threshold = .8)
output <- runPCPR2(DE_impLCMD$data, DE_impLCMD$sample_meta, pct.threshold = .8)
output <- runPCPR2(DE_impLCMD$data, DE_impLCMD$sample_meta, pct.threshold = .8)
output <- runPCPR2(as.matrix(DE_impLCMD$data), DE_impLCMD$sample_meta, pct.threshold = .8)
z_meta <- DE_impLCMD$sample_meta %>% select(c("biol.batch", "time.point", "condition", "sample_type"))
library(dplyr)
z_meta <- DE_impLCMD$sample_meta %>% select(c("biol.batch", "time.point", "condition", "sample_type"))
output <- runPCPR2(as.matrix(DE_impLCMD$data), z_meta, pct.threshold = .8)
transcripts
View(transcripts)
output <- runPCPR2(as.matrix(assay(DE_impLCMD)), z_meta, pct.threshold = .8)
output <- runPCPR2(as.matrix(assay(DE_impLCMD)), z_meta, pct.threshold = .5)
z_meta <- DE_impLCMD$sample_meta %>% select(c("time.point", "condition", "sample_type"))
DE_impLCMD$sample_meta
output <- runPCPR2(as.matrix(assay(DE_impLCMD)), z_meta, pct.threshold = .5)
output <- runPCPR2(transcripts, Z_metadata)
output$pR2
output <- runPCPR2(as.matrix(assay(DE_impLCMD)), z_meta, pct.threshold = .1)
output <- runPCPR2(transcripts, Z_metadata)
output <- runPCPR2(as.matrix(assay(DE_impLCMD)), z_meta, pct.threshold = .9)
output <- runPCPR2(as.matrix(assay(DE_impLCMD)), z_meta)
z_meta <- DE_impLCMD$sample_meta %>% select(c("time.point", "condition"))
DE_impLCMD$sample_meta
output <- runPCPR2(as.matrix(assay(DE_impLCMD)), z_meta)
z_meta <- DE_impLCMD$sample_meta %>% select(c("condition"))
DE_impLCMD$sample_meta
output <- runPCPR2(as.matrix(assay(DE_impLCMD)), z_meta)
output$pR2
z_meta <- DE_impLCMD$sample_meta %>% select(c("condition", "time.point"))
DE_impLCMD$sample_meta
output <- runPCPR2(as.matrix(assay(DE_impLCMD)), z_meta)
.vsc.attach()
session_info()
## install additional bioc packages for vignette if needed
#BiocManager::install(c('pmp', 'ropls', 'BiocFileCache'))
## install additional CRAN packages if needed
#install.packages(c('cowplot', 'openxlsx'))
suppressPackageStartupMessages({
# Bioconductor packages
library(structToolbox)
library(pmp)
library(ropls)
library(BiocFileCache)
# CRAN libraries
library(ggplot2)
library(gridExtra)
library(cowplot)
library(openxlsx)
})
# use the BiocFileCache
bfc <- BiocFileCache(ask = FALSE)
renv::snapshot()
renv::update()
renv::snapshot()
