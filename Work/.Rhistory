DE_impLCMD$data <-  impute.QRILC(assay(DE_f))
DE_impLCMD <- DE_f
assay(DE_impLCMD) <-  impute.QRILC(assay(DE_impLCMD))
DE_impLCMD@assays@data
View(DE_impLCMD@assays@data@listData[[1]])
DE_impLCMD@assays@data@listData[[1]]) <-  impute.LCMD(DE_impLCMD@assays@data@listData[[1]])
DE_impLCMD@assays@data@listData[[1]] <-  impute.LCMD(DE_impLCMD@assays@data@listData[[1]])
DE_impLCMD@assays@data@listData[[1]] <-  impute.QRILC(DE_impLCMD@assays@data@listData[[1]])
DE_impLCMD <- imputeLCMD(assay(DE_f))
DE_impLCMD <- impute.QRILC(assay(DE_f))
aggr(DE_impLCMD)
DE_impLCMD
# Impute Missing Values
# Impute missing values using missForest
library(missForest)
DE_impForest <- missForest(assay(DE_f), maxiter = 10, ntree = 100)
# Impute missing values using imputeLCMD
library(imputeLCMD)
DE_impLCMD <- impute.QRILC(assay(DE_f))
# Compare the imputed datasets
aggr(assay(DE_f))
# aggr(DE_impForest$ximp)
# aggr(DE_impLCMD)
View(DE_impLCMD)
QRILC_result <- impute.QRILC(assay(DE_f))
DE_impLCMD <- QRILC_result[[1]]
DE_impLCMD <- DE_f
assay(DE_impLCMD) <- QRILC_result[[1]]
aggr(assay(QRILC_result[[1]]))))
aggr(assay(DE_impLCMD))
DE_impForest <- missForest(assay(DE_f), maxiter = 10, ntree = 100)
DE_impForest <- DE_f
forest_result <- missForest(assay(DE_f), maxiter = 10, ntree = 100)
View(forest_result)
assay(DE_impForest) <- forest_result$ximp
PCA(DE_impForest, number_components = 5)
PCA(DE_f, number_components = 5)
P <- PCA(number_components = 5)
P <-  model_apply(P, DE_impForest)
Q <- PCA(number_components = 5)
Q <-  model_apply(Q, DE_impLCMD)
C = pca_scores_plot(factor_name = k)
g = list()
for (k in colnames(DE_impForest$sample_meta)) {
C = pca_scores_plot(factor_name = k)
g[[k]] = chart_plot(C,P[2])
}
C = pca_scores_plot(factor_name = 'condition')
chart_plot(C, P)
P <- PCA(number_components = 5)
PF <-  model_apply(P, DE_impForest)
PQ <-  model_apply(P, DE_impLCMD)
chart_plot(C, PF)
chart_plot(C, PQ)
C = pca_scores_plot(factor_name = 'condition')
chart_plot(C, PF)
chart_plot(C, PQ)
PDE <-  model_apply(P, DE)
impute_QRILC <- function(dataset_experiment) {
# Load required library
library(imputeLCMD)
# Create a copy of the DatasetExperiment object
DE_imp <- dataset_experiment
# Impute missing values
imputed_data <- impute.QRILC(assay(dataset_experiment))
# Replace missing values with imputed values
assay(DE_imp) <- imputed_data[[1]]
return(DE_imp)
}
DE_QRILC <- impute_QRILC(DE)
PDE <-  model_apply(P, DE)
PDE <-  model_apply(P, DE_QRILC)
C = pca_scores_plot(factor_name = 'condition')
chart_plot(C, PDE)
impute_forest <- function(dataset_experiment) {
# Load required library
library(missForest)
# Create a copy of the DatasetExperiment object
DE_imp <- dataset_experiment
# Impute missing values
forest_result <- missForest(assay(dataset_experiment), maxiter = 10, ntree = 100)
# Replace missing values with imputed values
assay(DE_imp) <- forest_result$ximp
return(DE_imp)
}
DE_Forest <- impute_forest(DE)
DE_Forest <- impute_forest(DE)
C = pca_scores_plot(factor_nam
C = pca_scores_plot(factor_nam
DE_Forest <- impute_forest(DE)
PFDE <- model_apply(P, DE_Forest)
C = pca_scores_plot(factor_name = 'condition')
chart_plot(C, PFDE)
chart_plot(C, PF)
chart_plot(C, PQ)
chart_plot(C, PDE)
chart_plot(C, PFDE)
AP <- autoscale() + PCA(number_components = 5)
APF <- model_apply(AP, DE_impForest)
APDE <- model_apply(AP, DE_QRILC)
APFDE <- model_apply(AP, DE_Forest)
C = pca_scores_plot(factor_name = 'condition')
chart_plot(C, AP)
chart_plot(C, APF)
chart_plot(C, APQ)
chart_plot(C, AP)
AP <- autoscale() + PCA(number_components = 5)
APF <- model_apply(AP, DE_impForest)
APQ <- model_apply(AP, DE_impLCMD)
APDE <- model_apply(AP, DE_QRILC)
APFDE <- model_apply(AP, DE_Forest)
chart_plot(C, APF)
APF
chart_plot(C, APF[2])
P <- PCA(number_components = 5)
PF <-  model_apply(P, DE_impForest)
PQ <-  model_apply(P, DE_impLCMD)
PDE <-  model_apply(P, DE_QRILC)
PFDE <- model_apply(P, DE_Forest)
AP <- autoscale() + PCA(number_components = 5)
APF <- model_apply(AP, DE_impForest)
APQ <- model_apply(AP, DE_impLCMD)
APDE <- model_apply(AP, DE_QRILC)
APFDE <- model_apply(AP, DE_Forest)
C = pca_scores_plot(factor_name = 'condition')
chart_plot(C, PF)
chart_plot(C, PQ)
chart_plot(C, PDE)
chart_plot(C, PFDE)
chart_plot(C, APF[2])
chart_plot(C, APQ[2])
chart_plot(C, APDE[2])
chart_plot(C, APFDE[2])
## install additional bioc packages for vignette if needed
#BiocManager::install(c('pmp', 'ropls', 'BiocFileCache'))
## install additional CRAN packages if needed
#install.packages(c('cowplot', 'openxlsx'))
suppressPackageStartupMessages({
# Bioconductor packages
library(SummarizedExperiment)
library(structToolbox)
library(pmp)
library(ropls)
library(BiocFileCache)
# CRAN libraries
library(ggplot2)
library(gridExtra)
library(cowplot)
library(openxlsx)
library(VIM)
})
# use the BiocFileCache
bfc <- BiocFileCache(ask = FALSE)
# path to zip
zipfile = "https://raw.github.com/STATegraData/STATegraData/master/Script_STATegra_Metabolomics.zip"
## retrieve from BiocFileCache
path = bfcrpath(bfc,zipfile)
temp = bfccache(bfc)
## ... or download to temp location
# path = tempfile()
# temp = tempdir()
# download.file(zipfile,path)
# unzip
unzip(zipfile=path, files = "LC_MS_raw_data.xlsx", exdir=temp)
# read samples
data <- as.data.frame(read.xlsx(file.path(temp,"LC_MS_raw_data.xlsx"),sheet = 'Data'))
# extract sample meta data (Cols 1 to 8)
SM = data[ ,1:8]
# add coloumn for sample type (QC, blank etc)
# Add blanks id
blanks=c(1,2,33,34,65,66)
# add QC id
QCs=c(3,4,11,18,25,32,35,36,43,50,57,64)
# add sample type
SM$sample_type='Sample'
# add blanks
SM$sample_type[blanks]='Blank'
# add QCs
SM$sample_type[QCs]='QC'
# put qc/blank labels in all factors for plotting later
SM$biol.batch[SM$sample_type!='Sample']=SM$sample_type[SM$sample_type!='Sample']
SM$time.point[SM$sample_type!='Sample']=SM$sample_type[SM$sample_type!='Sample']
SM$condition[SM$sample_type!='Sample']=SM$sample_type[SM$sample_type!='Sample']
# convert to factors
SM$biol.batch=ordered(SM$biol.batch,c('9','10','11','12','QC','Blank'))
SM$time.point=ordered(SM$time.point,c('0h','2h','6h','12h','18h','24h','QC','Blank'))
SM$condition=factor(SM$condition)
SM$sample_type=factor(SM$sample_type)
# variable meta data
# Use the colnames of the data as the variable meta data
colnames(data)=gsub("-", "_", colnames(data))
VM = data.frame('annotation'=colnames(data)[9:ncol(data)])
# Create the raw data matrix
X = data[,9:ncol(data)]
# convert 0 to NA
X[X==0]=NA
# force to numeric; any non-numerics will become NA
X=data.frame(lapply(X,as.numeric),check.names = FALSE)
# make sure row/col names match
rownames(X)=data$label
rownames(SM)=data$label
rownames(VM)=colnames(X)
# create DatasetExperiment object
DE = DatasetExperiment(
data = X,
sample_meta = SM,
variable_meta = VM,
name = 'STATegra Metabolomics LCMS',
description = 'https://www.nature.com/articles/s41597-019-0202-7'
)
DE
# prepare model sequence
MS = filter_smeta(mode = 'include', levels='QC', factor_name = 'sample_type') +
knn_impute(neighbours=5) +
vec_norm() +
log_transform(base = 10)
# apply model sequence
MS = model_apply(MS, DE)
install_github("JoeRothwell/pcpr2")
library(devtools)
install_github("JoeRothwell/pcpr2")
library(pcpr2)
filter_MV <- function(dataset_exp, threshold = 0.8) {
# Check if threshold is specified and valid
if (missing(threshold)) {
threshold <- 0.8  # Default threshold
cat("No threshold specified. Defaulting to 0.8.\n")
} else {
# Check if threshold is between 0 and 1
if (threshold < 0 || threshold > 1) {
stop("Threshold must be between 0 and 1.")
}
# Check if threshold is a numeric value
if (!is.numeric(threshold)) {
stop("Threshold must be a numeric value.")
}
cat(paste0("Threshold value: ", threshold, "\n"))
}
# Calculate number of rows and columns in the dataset
nrows <- nrow(assay(dataset_exp))
ncols <- ncol(assay(dataset_exp))
# Calculate the threshold values based on the modified 80% rule
row_threshold <- ncols * threshold
col_threshold <- nrows * threshold
# Filter rows based on the modified 80% rule
row_counts <- rowSums(!is.na(assay(dataset_exp)))
dataset_exp <- dataset_exp[row_counts >= row_threshold, ]
# Filter columns based on the modified 80% rule
col_counts <- colSums(!is.na(assay(dataset_exp)))
dataset_exp <- dataset_exp[, col_counts >= col_threshold]
# Calculate the number of rows and columns removed
removed_rows <- nrows - sum(row_counts >= row_threshold)
removed_cols <- ncols - sum(col_counts >= col_threshold)
# Print information about removed rows and columns
if (removed_rows == 0) {
cat('No rows removed\n')
} else {
cat(paste0('Number of rows removed: ', removed_rows, '\n'))
}
if (removed_cols == 0) {
cat('No columns removed\n')
} else {
cat(paste0('Number of columns removed: ', removed_cols, '\n'))
}
return(dataset_exp)
}
aggr(assay(DE))
DE_f<- filter_MV(DE, threshold = 0.8)
aggr(assay(DE_f))
C = mv_histogram(by_sample = FALSE)
chart_plot(C, DE)
chart_plot(C, DE_f)
# Impute Missing Values
# Impute missing values using missForest
library(missForest)
# Create new DatasetExperiment object
DE_impForest <- DE_f
# Impute missing values
forest_result <- missForest(assay(DE_f), maxiter = 10, ntree = 100)
# Replace missing values with imputed values
assay(DE_impForest) <- forest_result$ximp
impute_forest <- function(dataset_experiment) {
# Load required library
library(missForest)
# Create a copy of the DatasetExperiment object
DE_imp <- dataset_experiment
# Impute missing values
forest_result <- missForest(assay(dataset_experiment), maxiter = 10, ntree = 100)
# Replace missing values with imputed values
assay(DE_imp) <- forest_result$ximp
return(DE_imp)
}
# Impute missing values using imputeLCMD
library(imputeLCMD)
# Create new DatasetExperiment object
DE_impLCMD <- DE_f
# Impute missing values
QRILC_result <- impute.QRILC(assay(DE_f))
# Replace missing values with imputed values
assay(DE_impLCMD) <- QRILC_result[[1]]
impute_QRILC <- function(dataset_experiment) {
# Load required library
library(imputeLCMD)
# Create a copy of the DatasetExperiment object
DE_imp <- dataset_experiment
# Impute missing values
imputed_data <- impute.QRILC(assay(dataset_experiment))
# Replace missing values with imputed values
assay(DE_imp) <- imputed_data[[1]]
return(DE_imp)
}
output <- runPCPR2(assay(DE_impLCMD), DE_impLCMD$sample_meta, pct.threshold = .8)
output <- runPCPR2(assay(DE_impLCMD), DE_impLCMD$sample_meta, pct.threshold = .8)
output <- runPCPR2(DE_impLCMD$data, DE_impLCMD$sample_meta, pct.threshold = .8)
output <- runPCPR2(DE_impLCMD$data, DE_impLCMD$sample_meta, pct.threshold = .8)
output <- runPCPR2(as.matrix(DE_impLCMD$data), DE_impLCMD$sample_meta, pct.threshold = .8)
z_meta <- DE_impLCMD$sample_meta %>% select(c("biol.batch", "time.point", "condition", "sample_type"))
library(dplyr)
z_meta <- DE_impLCMD$sample_meta %>% select(c("biol.batch", "time.point", "condition", "sample_type"))
output <- runPCPR2(as.matrix(DE_impLCMD$data), z_meta, pct.threshold = .8)
transcripts
View(transcripts)
output <- runPCPR2(as.matrix(assay(DE_impLCMD)), z_meta, pct.threshold = .8)
output <- runPCPR2(as.matrix(assay(DE_impLCMD)), z_meta, pct.threshold = .5)
z_meta <- DE_impLCMD$sample_meta %>% select(c("time.point", "condition", "sample_type"))
DE_impLCMD$sample_meta
output <- runPCPR2(as.matrix(assay(DE_impLCMD)), z_meta, pct.threshold = .5)
output <- runPCPR2(transcripts, Z_metadata)
output$pR2
output <- runPCPR2(as.matrix(assay(DE_impLCMD)), z_meta, pct.threshold = .1)
output <- runPCPR2(transcripts, Z_metadata)
output <- runPCPR2(as.matrix(assay(DE_impLCMD)), z_meta, pct.threshold = .9)
output <- runPCPR2(as.matrix(assay(DE_impLCMD)), z_meta)
z_meta <- DE_impLCMD$sample_meta %>% select(c("time.point", "condition"))
DE_impLCMD$sample_meta
output <- runPCPR2(as.matrix(assay(DE_impLCMD)), z_meta)
z_meta <- DE_impLCMD$sample_meta %>% select(c("condition"))
DE_impLCMD$sample_meta
output <- runPCPR2(as.matrix(assay(DE_impLCMD)), z_meta)
output$pR2
z_meta <- DE_impLCMD$sample_meta %>% select(c("condition", "time.point"))
DE_impLCMD$sample_meta
output <- runPCPR2(as.matrix(assay(DE_impLCMD)), z_meta)
.vsc.attach()
session_info()
## install additional bioc packages for vignette if needed
#BiocManager::install(c('pmp', 'ropls', 'BiocFileCache'))
## install additional CRAN packages if needed
#install.packages(c('cowplot', 'openxlsx'))
suppressPackageStartupMessages({
# Bioconductor packages
library(structToolbox)
library(pmp)
library(ropls)
library(BiocFileCache)
# CRAN libraries
library(ggplot2)
library(gridExtra)
library(cowplot)
library(openxlsx)
})
# use the BiocFileCache
bfc <- BiocFileCache(ask = FALSE)
renv::snapshot()
renv::update()
renv::snapshot()
source("C:/Users/eduar/Desktop/TFM/Work/R/GenerateTargets.R")
source("C:/Users/eduar/Desktop/TFM/Work/R/GenerateTargets.R")
additive_functions <- AdditiveFunctions()
View(additive_functions)
additive_functions <- additive_functions + function1() + function2() + function3() + function4()
additive_functions <- additive_functions + import_data()
additive_functions <- additive_functions + rownames()
additive_functions <- additive_functions + rownames(X)
source("C:/Users/eduar/Desktop/TFM/Work/R/GenerateTargets.R")
metanr_packages <- function(){
metr_pkgs <- c("impute", "pcaMethods", "globaltest", "GlobalAncova", "Rgraphviz", "preprocessCore", "genefilter", "SSPA", "sva", "limma", "KEGGgraph", "siggenes","BiocParallel", "MSnbase", "multtest", "RBGL", "edgeR", "fgsea", "devtools", "crmn")
list_installed <- installed.packages()
new_pkgs <- subset(metr_pkgs, !(metr_pkgs %in% list_installed[, "Package"]))
if(length(new_pkgs)!=0){if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install(new_pkgs)
print(c(new_pkgs, " packages added..."))
}
if((length(new_pkgs)<1)){
print("No new packages added...")
}
}
metanr_packages()
devtools::install_github("xia-lab/MetaboAnalystR", build = TRUE, build_vignettes = TRUE, build_manual =T)
library(MetaboAnalystR)
View(X)
View(DE)
View(DE@assays@data@listData[[1]])
View(SM)
A <- rsd_filter(rsd_threshold = .2, qc_label= "QC", factor_name = "condition")
A <- model_apply(A,DE)
filtered <- predicted(A)
View(filtered)
filtered
DE
A <- rsd_filter(rsd_threshold = 20, qc_label= "QC", factor_name = "condition")
A <- model_apply(A,DE)
filtered <- predicted(A)
filtered
source("C:/Users/eduar/Desktop/TFM/Work/R/filter.R")
## SBCORRECTION (QC-RSC) to correct for signal drift and batch
B <- sb_corr(order_col = "order", batch_col = "biol.batch", qc_col = "sample_type", qc_label = 'QC')
B
DE_corrected <- model_apply(B, DE)
## SBCORRECTION (QC-RSC) to correct for signal drift and batch
B <- sb_corr(order_col = "order", batch_col = "biol.batch", qc_col = "sample_type", qc_label = 'QC')
DE_corrected <- model_apply(B, QRImputed_experiment)
QRImputed_experiment <- impute_QRILC(filtered_experiment)
source("C:/Users/eduar/Desktop/TFM/Work/Training/Testfunctions.R")
source("C:/Users/eduar/Desktop/TFM/Work/R/createExperiment.R")
source("C:/Users/eduar/Desktop/TFM/Work/R/filter.R")
# use the BiocFileCache
bfc <- BiocFileCache(ask = FALSE)
# path to zip
zipfile = "https://raw.github.com/STATegraData/STATegraData/master/Script_STATegra_Metabolomics.zip"
## retrieve from BiocFileCache
path = bfcrpath(bfc,zipfile)
temp = bfccache(bfc)
## ... or download to temp location
# path = tempfile()
# temp = tempdir()
# download.file(zipfile,path)
# unzip
unzip(zipfile=path, files = "LC_MS_raw_data.xlsx", exdir=temp)
# read samples
data <- as.data.frame(read.xlsx(file.path(temp,"LC_MS_raw_data.xlsx"),sheet = 'Data'))
##### PREPARING DATA FOR EXPERIMENT ######
# Create SampleMetadata dataframe
SM <- data[,1:7]
SM$sample_id = SM$label
# Define QC and blank samples
blanks=c(1,2,33,34,65,66)
QCs=c(3,4,11,18,25,32,35,36,43,50,57,64)
SM$sample_type = "Sample"
SM$sample_type[blanks] = "Blank"
SM$sample_type[QCs] = "QC"
# Create variableMetadata object
VM = data.frame('annotation'=colnames(data)[8:ncol(data)])
# Create the raw data matrix
X = data[,8:ncol(data)]
X$sample_id = SM$sample_id
# Create the experiment
DE <- createExperiment(X, SM, VM, "LCMS Raw test", "Description Test")
source("C:/Users/eduar/Desktop/TFM/Work/R/createExperiment.R")
source("C:/Users/eduar/Desktop/TFM/Work/R/imputation.R")
source("C:/Users/eduar/Desktop/TFM/Work/R/filter.R")
# use the BiocFileCache
bfc <- BiocFileCache(ask = FALSE)
# path to zip
zipfile = "https://raw.github.com/STATegraData/STATegraData/master/Script_STATegra_Metabolomics.zip"
## retrieve from BiocFileCache
path = bfcrpath(bfc,zipfile)
temp = bfccache(bfc)
## ... or download to temp location
# path = tempfile()
# temp = tempdir()
# download.file(zipfile,path)
# unzip
unzip(zipfile=path, files = "LC_MS_raw_data.xlsx", exdir=temp)
# read samples
data <- as.data.frame(read.xlsx(file.path(temp,"LC_MS_raw_data.xlsx"),sheet = 'Data'))
##### PREPARING DATA FOR EXPERIMENT ######
# Create SampleMetadata dataframe
SM <- data[,1:7]
SM$sample_id = SM$label
# Define QC and blank samples
blanks=c(1,2,33,34,65,66)
QCs=c(3,4,11,18,25,32,35,36,43,50,57,64)
SM$sample_type = "Sample"
SM$sample_type[blanks] = "Blank"
SM$sample_type[QCs] = "QC"
# Create variableMetadata object
VM = data.frame('annotation'=colnames(data)[8:ncol(data)])
# Create the raw data matrix
X = data[,8:ncol(data)]
X$sample_id = SM$sample_id
# Create the experiment
DE <- createExperiment(X, SM, VM, "LCMS Raw test", "Description Test")
DE
# Filter NA
filtered_experiment <- filter_MV(DE)
filtered_experiment
QRImputed_experiment <- impute_QRILC(filtered_experiment)
RFImputed_experiment <- impute_RF(filtered_experiment)
## SBCORRECTION (QC-RSC) to correct for signal drift and batch
B <- sb_corr(order_col = "order", batch_col = "biol.batch", qc_col = "sample_type", qc_label = 'QC')
DE_corrected <- model_apply(B, QRImputed_experiment)
DE_corrected <- model_apply(B, RFImputed_experiment)
View(DE_corrected)
DE_corrected <- model_apply(RFImputed_experiment, B)
DE_corrected <- model_apply(B, RFImputed_experiment)
## SBCORRECTION (QC-RSC) to correct for signal drift and batch
B <- sb_corr(order_col = "order", batch_col = "biol.batch", qc_col = "sample_type", qc_label = 'QC')
B <- model_apply(B, RFImputed_experiment)
test <- predicted(B)
View(test)
View(test@assays@data@listData[[1]])
## SBCORRECTION (QC-RSC) to correct for signal drift and batch
B <- sb_corr(order_col = "order", batch_col = "biol.batch", qc_col = "sample_type", qc_label = 'QC')
B <- model_apply(B, QRImputed_experiment)
test <- predicted(B)
View(test@assays@data@listData[[1]])
## SBCORRECTION (QC-RSC) to correct for signal drift and batch
B <- sb_corr(order_col = "order", batch_col = "biol.batch", qc_col = "sample_type", qc_label = 'QC')
View(B)
B <- model_apply(B, DE)
